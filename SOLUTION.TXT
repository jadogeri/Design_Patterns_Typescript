https://medium.com/@vinodkumarbheel61/builder-design-pattern-in-java-a-practical-guide-8a9aaf3d51a3



The Factory Method design pattern in Java, when implemented with SOLID principles, provides a robust and flexible way to create objects.
Relationship with SOLID Principles:
Single Responsibility Principle (SRP):
The factory class's primary responsibility is solely object creation, separating this concern from the client classes that use the objects.
Open/Closed Principle (OCP):
The Factory Method allows for the introduction of new product types without modifying existing client code or the core factory interface. New concrete factories and product implementations can be added, extending the system without altering established code.
Dependency Inversion Principle (DIP):
High-level modules (clients and abstract factory/product interfaces) depend on abstractions, not on concrete low-level modules (concrete factories and products). This inversion of control promotes loose coupling.
Implementation Example in Java:
Java

// Product Interface
interface Product {
    void doSomething();
}

// Concrete Products
class ConcreteProductA implements Product {
    @Override
    public void doSomething() {
        System.out.println("Doing something in ConcreteProductA");
    }
}

class ConcreteProductB implements Product {
    @Override
    public void doSomething() {
        System.out.println("Doing something in ConcreteProductB");
    }
}

// Abstract Factory Method Interface
interface ProductFactory {
    Product createProduct();
}

// Concrete Factories
class ConcreteProductAFactory implements ProductFactory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

class ConcreteProductBFactory implements ProductFactory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}

// Client Code
public class Client {
    public static void main(String[] args) {
        ProductFactory factoryA = new ConcreteProductAFactory();
        Product productA = factoryA.createProduct();
        productA.doSomething();

        ProductFactory factoryB = new ConcreteProductBFactory();
        Product productB = factoryB.createProduct();
        productB.doSomething();
    }
}
In this example:
Product is the abstract product, and ConcreteProductA and ConcreteProductB are concrete implementations.
ProductFactory is the abstract factory, with createProduct() as the factory method.
ConcreteProductAFactory and ConcreteProductBFactory are concrete factories responsible for instantiating their respective products.
The Client interacts with the ProductFactory interface, adhering to DIP and allowing for easy extension (OCP) by adding new Product and ProductFactory implementations without modifying the Client itself.
